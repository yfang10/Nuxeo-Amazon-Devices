<!--
`amzd-form-checkbox-aggregation`
@group Nuxeo UI
@element amzd-form-checkbox-aggregation
-->
<dom-module id="amzd-form-checkbox-aggregation">
    <template>
      <style>
       :host {
         @apply --layout-vertical;
       }
       h4{
        display: flex;
       }
       paper-checkbox {
          --paper-checkbox-label-spacing: 10px;
          margin-bottom: 8px;
          display: flex;
       }
     </style>
     <dom-if if="[[checkname]]">
      <template>
      <h4><paper-checkbox checked="{{checked}}" on-change="_checkAll"></paper-checkbox>[[checkname]]</h4>
    </template>
    </dom-if>
      <dom-repeat items="{{buckets}}" index-as="index">
        <template>
          <paper-checkbox checked="{{item.checked}}" on-change="_computeValues">
            [[item.label]] ([[item.docCount]])
          </paper-checkbox>
        </template>
      </dom-repeat>
      <dom-if if="[[_isEmpty]]">
        <template>
          <label>[[i18n('checkboxAggregation.noResults')]]</label>
        </template>
      </dom-if>
    </template>
  
    <script>
      Polymer({
        is: 'amzd-form-checkbox-aggregation',
        behaviors: [Nuxeo.I18nBehavior],
        properties: {
          data: {
            type: Object,
          },
  
          value: {
            type: Array,
            value: [],
            notify: true,
          },
  
          buckets: {
            type: Object,
            computed: '_computeBuckets(data)',
          },
  
          _isEmpty: {
            type: Boolean,
            value: true,
          },

          checked: {
            type: Boolean,
            value: false,
          },

          checkname: {
            type: String,
            value:null
          },


  
          /**
           * Sort buckets by label instead of doc count.
           */
          sortByLabel: Boolean,
  
          /**
           * Function used to format the label of the aggregate entry.
           */
          labelFormatter: {
            type: Function,
            value() {
              return this._computeLabel.bind(this);
            },
          },
          selectedTimeFrame: {
            type: String,
            value: 'permanent'
          }
        },
  
        observers: [
          '_observeData(data)'
        ],
  
        _observeData() {
          if (this.data && this.data.extendedBuckets) {
            this._isEmpty = this.data.extendedBuckets.length === 0;
          } else {
            this._isEmpty = true;
          }
        },
  
        _computeBuckets(data) {
          if (data) {
            const buckets = data.extendedBuckets;
            const selectedBuckets = data.selection;
            buckets.forEach((item) => {
              item.checked = selectedBuckets.indexOf(item.key) >= 0;
              item.label = this.labelFormatter(item);
            });
              buckets.sort((a, b) => {
                let upA = a.label.toUpperCase();
                let upB = b.label.toUpperCase();
                if (upA < upB) {
                  return -1;
                } else if (upA > upB) {
                  return 1;
                }
                return 0;
              });
            return buckets;
          }
        },
  
        _computeValues() {
          const values = [];
          this.buckets.forEach((item) => {
            if (item.checked) {
              values.push(item.key);
            }
          });
          this.value = values;
          // console.log("单选--", this.buckets,values)
        },

        _checkAll() {
          var cbs = this.shadowRoot.querySelectorAll('paper-checkbox') ;
          for(var i = 0; i < cbs.length; i++) {
            cbs[i].checked = this.checked
          }
          this._computeValues()
          // console.log("全选--", this.buckets,cbs)
        },
  
        _computeLabel(item) {
          let i18nKey;
          if (item.fetchedKey) {
            const entry = item.fetchedKey;
            if (entry['entity-type'] === 'directoryEntry') {
              return this.labelForDirectoryEntry(entry);
            } else if (entry['entity-type'] === 'user') {
              return this.labelForUserEntry(entry);
            } else if (entry['entity-type'] === 'document') {
              return entry.properties['dc:title'] || entry['title'] || this.i18n('aggregation.format.document.field.unknown', 'dc:title');
            } else {
              i18nKey = this.i18n(`label.ui.aggregate.${item.key}`);
              return i18nKey === `label.ui.aggregate.${item.key}` ? item.key : i18nKey;
            }
          } else {
            i18nKey = this.i18n(`label.ui.aggregate.${item.key}`);
            return i18nKey === `label.ui.aggregate.${item.key}` ? item.key : i18nKey;
          }
        },
  
        labelForDirectoryEntry(entry) {
          let lang = window.nuxeo.I18n.language || 'en';
          if (lang.indexOf('-') > -1) {
            lang = lang.split('-')[0];
          }
          const labels = [];
          while (entry) {
            if (entry.properties[`label_${lang}`]) {
              labels.push(entry.properties[`label_${lang}`]);
            } else if (entry.properties.label) {
              labels.push(entry.properties.label);
            } else if (entry.properties.label_en) {
              labels.push(entry.properties.label_en);
            } else {
              labels.push(entry.properties.id);
            }
            entry = entry.properties.parent;
          }
          return labels.reverse().join('/');
        },
  
        labelForUserEntry(entry) {
          if (entry.properties === undefined) {
            return entry.id;
          } else if (entry.properties.firstName && entry.properties.firstName.length > 0
           && entry.properties.lastName && entry.properties.lastName.length > 0) {
            return `${entry.properties.firstName} ${entry.properties.lastName}`;
          } else {
            return entry.properties.username;
          }
        },
      });
    </script>
  </dom-module>
  