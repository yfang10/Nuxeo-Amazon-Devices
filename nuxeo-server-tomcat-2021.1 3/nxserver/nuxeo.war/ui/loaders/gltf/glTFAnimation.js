let glTFAnimator=function(){var t=[];return{add:function(i){t.push(i)},remove:function(i){var s=t.indexOf(i);-1!==s&&t.splice(s,1)},update:function(){for(var i=0;i<t.length;i++)t[i].update()}}}(),glTFAnimation=function(t){this.running=!1,this.loop=!1,this.duration=0,this.startTime=0,this.interps=[],t&&this.createInterpolators(t)};glTFAnimation.prototype.createInterpolators=function(t){var i,s=t.length;for(i=0;i<s;i++){var e=new glTFInterpolator(t[i]);this.interps.push(e),this.duration=Math.max(this.duration,e.duration)}},glTFAnimation.prototype.play=function(){this.running||(this.startTime=Date.now(),this.running=!0,glTFAnimator.add(this))},glTFAnimation.prototype.stop=function(){this.running=!1,glTFAnimator.remove(this)},glTFAnimation.prototype.update=function(){if(this.running){var t=(Date.now()-this.startTime)/1e3,i=t%this.duration;if(Math.floor(t/this.duration)>=1&&!this.loop){this.running=!1;var s=this.interps.length;for(e=0;e<s;e++)this.interps[e].interp(this.duration);this.stop()}else{var e;for(s=this.interps.length,e=0;e<s;e++)this.interps[e].interp(i)}}};let glTFInterpolator=function(t){this.keys=t.keys,this.values=t.values,this.count=t.count,this.type=t.type,this.path=t.path,this.isRot=!1;var i=t.target;switch(i.updateMatrix(),i.matrixAutoUpdate=!0,this.targetNode=i,t.path){case"translation":this.target=i.position,this.originalValue=i.position.clone();break;case"rotation":this.target=i.quaternion,this.originalValue=i.quaternion.clone(),this.isRot=!0;break;case"scale":this.target=i.scale,this.originalValue=i.scale.clone()}this.duration=this.keys[this.count-1],this.vec1=new THREE.Vector3,this.vec2=new THREE.Vector3,this.vec3=new THREE.Vector3,this.quat1=new THREE.Quaternion,this.quat2=new THREE.Quaternion,this.quat3=new THREE.Quaternion};glTFInterpolator.prototype.interp=function(t){var i;if(t==this.keys[0])this.isRot?this.quat3.set(this.values[0],this.values[1],this.values[2],this.values[3]):this.vec3.set(this.values[0],this.values[1],this.values[2]);else if(t<this.keys[0])this.isRot?(this.quat1.set(this.originalValue.x,this.originalValue.y,this.originalValue.z,this.originalValue.w),this.quat2.set(this.values[0],this.values[1],this.values[2],this.values[3]),THREE.Quaternion.slerp(this.quat1,this.quat2,this.quat3,t/this.keys[0])):(this.vec3.set(this.originalValue.x,this.originalValue.y,this.originalValue.z),this.vec2.set(this.values[0],this.values[1],this.values[2]),this.vec3.lerp(this.vec2,t/this.keys[0]));else if(t>=this.keys[this.count-1])this.isRot?this.quat3.set(this.values[4*(this.count-1)],this.values[4*(this.count-1)+1],this.values[4*(this.count-1)+2],this.values[4*(this.count-1)+3]):this.vec3.set(this.values[3*(this.count-1)],this.values[3*(this.count-1)+1],this.values[3*(this.count-1)+2]);else for(i=0;i<this.count-1;i++){var s=this.keys[i],e=this.keys[i+1];t>=s&&t<=e&&(this.isRot?(this.quat1.set(this.values[4*i],this.values[4*i+1],this.values[4*i+2],this.values[4*i+3]),this.quat2.set(this.values[4*(i+1)],this.values[4*(i+1)+1],this.values[4*(i+1)+2],this.values[4*(i+1)+3]),THREE.Quaternion.slerp(this.quat1,this.quat2,this.quat3,(t-s)/(e-s))):(this.vec3.set(this.values[3*i],this.values[3*i+1],this.values[3*i+2]),this.vec2.set(this.values[3*(i+1)],this.values[3*(i+1)+1],this.values[3*(i+1)+2]),this.vec3.lerp(this.vec2,(t-s)/(e-s))))}this.target&&this.copyValue(this.target)},glTFInterpolator.prototype.copyValue=function(t){this.isRot?t.copy(this.quat3):t.copy(this.vec3)};export{glTFAnimation,glTFAnimator,glTFInterpolator};