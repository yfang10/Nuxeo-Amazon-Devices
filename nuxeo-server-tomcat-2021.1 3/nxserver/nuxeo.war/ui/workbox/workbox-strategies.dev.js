this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,s,r,a,n){"use strict";try{self.workbox.v["workbox:strategies:3.6.3"]=1}catch(e){}var o=(e,t)=>`Using ${e} to respond to '${(e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href})(t.url)}'`,c=t=>{t&&(e.logger.groupCollapsed("View the final response here."),e.logger.unprefixed.log(t),e.logger.groupEnd())};class i{constructor(e={}){this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var s=this;return babelHelpers.asyncToGenerator((function*(){return t.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"handle",paramName:"event"}),s.makeRequest({event:e,request:e.request})}))()}makeRequest({event:s,request:a}){var n=this;return babelHelpers.asyncToGenerator((function*(){const i=[];"string"==typeof a&&(a=new Request(a)),t.assert.isInstance(a,Request,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"makeRequest",paramName:"request"});let l,u=yield r.cacheWrapper.match({cacheName:n._cacheName,request:a,event:s,matchOptions:n._matchOptions,plugins:n._plugins});if(u)i.push(`Found a cached response in the '${n._cacheName}' cache.`);else{i.push(`No response found in the '${n._cacheName}' cache. Will respond with a network request.`);try{u=yield n._getFromNetwork(a,s)}catch(e){l=e}u?i.push("Got response from network."):i.push("Unable to get a response from the network.")}e.logger.groupCollapsed(o("CacheFirst",a));for(let t of i)e.logger.log(t);if(c(u),e.logger.groupEnd(),l)throw l;return u}))()}_getFromNetwork(t,s){var o=this;return babelHelpers.asyncToGenerator((function*(){const c=yield a.fetchWrapper.fetch({request:t,event:s,fetchOptions:o._fetchOptions,plugins:o._plugins}),i=c.clone(),l=r.cacheWrapper.put({cacheName:o._cacheName,request:t,response:i,event:s,plugins:o._plugins});if(s)try{s.waitUntil(l)}catch(t){e.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${n.getFriendlyURL(s.request.url)}'.`)}return c}))()}}class l{constructor(e={}){this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._matchOptions=e.matchOptions||null}handle({event:e}){var s=this;return babelHelpers.asyncToGenerator((function*(){return t.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"handle",paramName:"event"}),s.makeRequest({event:e,request:e.request})}))()}makeRequest({event:s,request:a}){var n=this;return babelHelpers.asyncToGenerator((function*(){"string"==typeof a&&(a=new Request(a)),t.assert.isInstance(a,Request,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"makeRequest",paramName:"request"});const i=yield r.cacheWrapper.match({cacheName:n._cacheName,request:a,event:s,matchOptions:n._matchOptions,plugins:n._plugins});return e.logger.groupCollapsed(o("CacheOnly",a)),i?(e.logger.log(`Found a cached response in the '${n._cacheName}' cache.`),c(i)):e.logger.log(`No response found in the '${n._cacheName}' cache.`),e.logger.groupEnd(),i}))()}}var u={cacheWillUpdate:({response:e})=>e.ok||0===e.status?e:null};class h{constructor(e={}){if(this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),e.plugins){let t=e.plugins.some((e=>!!e.cacheWillUpdate));this._plugins=t?e.plugins:[u,...e.plugins]}else this._plugins=[u];this._networkTimeoutSeconds=e.networkTimeoutSeconds,this._networkTimeoutSeconds&&t.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"constructor",paramName:"networkTimeoutSeconds"}),this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var s=this;return babelHelpers.asyncToGenerator((function*(){return t.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"event"}),s.makeRequest({event:e,request:e.request})}))()}makeRequest({event:s,request:r}){var a=this;return babelHelpers.asyncToGenerator((function*(){const n=[];"string"==typeof r&&(r=new Request(r)),t.assert.isInstance(r,Request,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"makeRequest"});const i=[];let l;if(a._networkTimeoutSeconds){const{id:e,promise:t}=a._getTimeoutPromise({request:r,event:s,logs:n});l=e,i.push(t)}const u=a._getNetworkPromise({timeoutId:l,request:r,event:s,logs:n});i.push(u);let h=yield Promise.race(i);h||(h=yield u),e.logger.groupCollapsed(o("NetworkFirst",r));for(let t of n)e.logger.log(t);return c(h),e.logger.groupEnd(),h}))()}_getTimeoutPromise({request:e,logs:t,event:s}){var r=this;let a;const n=new Promise((n=>{const o=(c=babelHelpers.asyncToGenerator((function*(){t.push(`Timing out the network response at ${r._networkTimeoutSeconds} seconds.`),n(yield r._respondFromCache({request:e,event:s}))})),function(){return c.apply(this,arguments)});var c;a=setTimeout(o,1e3*this._networkTimeoutSeconds)}));return{promise:n,id:a}}_getNetworkPromise({timeoutId:t,request:s,logs:o,event:c}){var i=this;return babelHelpers.asyncToGenerator((function*(){let l,u;try{u=yield a.fetchWrapper.fetch({request:s,event:c,fetchOptions:i._fetchOptions,plugins:i._plugins})}catch(e){l=e}if(t&&clearTimeout(t),u?o.push("Got response from network."):o.push("Unable to get a response from the network. Will respond with a cached response."),l||!u)u=yield i._respondFromCache({request:s,event:c}),u?o.push(`Found a cached response in the '${i._cacheName}' cache.`):o.push(`No response found in the '${i._cacheName}' cache.`);else{const t=u.clone(),a=r.cacheWrapper.put({cacheName:i._cacheName,request:s,response:t,event:c,plugins:i._plugins});if(c)try{c.waitUntil(a)}catch(t){e.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${n.getFriendlyURL(c.request.url)}'.`)}}return u}))()}_respondFromCache({event:e,request:t}){return r.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins})}}class p{constructor(e={}){this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null}handle({event:e}){var s=this;return babelHelpers.asyncToGenerator((function*(){return t.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"event"}),s.makeRequest({event:e,request:e.request})}))()}makeRequest({event:s,request:r}){var n=this;return babelHelpers.asyncToGenerator((function*(){let i,l;"string"==typeof r&&(r=new Request(r)),t.assert.isInstance(r,Request,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"request"});try{l=yield a.fetchWrapper.fetch({request:r,event:s,fetchOptions:n._fetchOptions,plugins:n._plugins})}catch(e){i=e}if(e.logger.groupCollapsed(o("NetworkOnly",r)),l?e.logger.log("Got response from network."):e.logger.log("Unable to get a response from the network."),c(l),e.logger.groupEnd(),i)throw i;return l}))()}}class m{constructor(e={}){if(this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],e.plugins){let t=e.plugins.some((e=>!!e.cacheWillUpdate));this._plugins=t?e.plugins:[u,...e.plugins]}else this._plugins=[u];this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var s=this;return babelHelpers.asyncToGenerator((function*(){return t.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"event"}),s.makeRequest({event:e,request:e.request})}))()}makeRequest({event:s,request:a}){var i=this;return babelHelpers.asyncToGenerator((function*(){const l=[];"string"==typeof a&&(a=new Request(a)),t.assert.isInstance(a,Request,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"request"});const u=i._getFromNetwork({request:a,event:s});let h=yield r.cacheWrapper.match({cacheName:i._cacheName,request:a,event:s,matchOptions:i._matchOptions,plugins:i._plugins});if(h){if(l.push(`Found a cached response in the '${i._cacheName}' cache. Will update with the network response in the background.`),s)try{s.waitUntil(u)}catch(t){e.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${n.getFriendlyURL(s.request.url)}'.`)}}else l.push(`No response found in the '${i._cacheName}' cache. Will wait for the network response.`),h=yield u;e.logger.groupCollapsed(o("StaleWhileRevalidate",a));for(let t of l)e.logger.log(t);return c(h),e.logger.groupEnd(),h}))()}_getFromNetwork({request:t,event:s}){var o=this;return babelHelpers.asyncToGenerator((function*(){const c=yield a.fetchWrapper.fetch({request:t,event:s,fetchOptions:o._fetchOptions,plugins:o._plugins}),i=r.cacheWrapper.put({cacheName:o._cacheName,request:t,response:c.clone(),event:s,plugins:o._plugins});if(s)try{s.waitUntil(i)}catch(t){e.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${n.getFriendlyURL(s.request.url)}'.`)}return c}))()}}var g=Object.freeze({CacheFirst:i,CacheOnly:l,NetworkFirst:h,NetworkOnly:p,StaleWhileRevalidate:m});const N={cacheFirst:i,cacheOnly:l,networkFirst:h,networkOnly:p,staleWhileRevalidate:m},d={};return Object.keys(N).forEach((e=>{d[e]=(t={})=>new(0,N[e])(Object.assign(t))})),Object.assign(d,g)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);