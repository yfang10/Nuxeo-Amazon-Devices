this.workbox=this.workbox||{},this.workbox.routing=function(e,t,r,o,a){"use strict";try{self.workbox.v["workbox:routing:3.6.3"]=1}catch(e){}const s=["DELETE","GET","HEAD","PATCH","POST","PUT"];var n=t=>t&&"object"==typeof t?(e.assert.hasMethod(t,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),t):(e.assert.isType(t,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:t});class i{constructor(t,r,o){e.assert.isType(t,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),o&&e.assert.isOneOf(o,s,{paramName:"method"}),this.handler=n(r),this.match=t,this.method=o||"GET"}}class u extends i{constructor(r,o,a){e.assert.isInstance(r,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"}),super((({url:e})=>{const o=r.exec(e.href);return o?e.origin!==location.origin&&0!==o.index?(t.logger.debug(`The regular expression '${r}' only partially matched against the cross-origin URL '${e}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`),null):o.slice(1):null}),o,a)}}class l{constructor(){this._routes=new Map}handleRequest(r){e.assert.isInstance(r,FetchEvent,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"event"});const a=new URL(r.request.url);if(!a.protocol.startsWith("http"))return void t.logger.debug("Workbox Router only supports URLs that start with 'http'.");let s=null,n=null,i=null,u=[];const l=this._findHandlerAndParams(r,a);if(n=l.handler,i=l.params,s=l.route,n&&(u.push(["Found a route to handle this request:",s]),i&&u.push(["Passing the following params to the route's handler:",i])),!n&&this._defaultHandler&&(u.push("Failed to find a matching route. Falling back to the default handler."),s="[Default Handler]",n=this._defaultHandler),!n)return void t.logger.debug(`No route found for: ${o.getFriendlyURL(a)}`);let h;t.logger.groupCollapsed(`Router is responding to: ${o.getFriendlyURL(a)}`),u.forEach((e=>{Array.isArray(e)?t.logger.log(...e):t.logger.log(e)})),t.logger.groupCollapsed("View request details here."),t.logger.unprefixed.log(r.request),t.logger.groupEnd(),t.logger.groupEnd();try{h=n.handle({url:a,event:r,params:i})}catch(e){h=Promise.reject(e)}return h&&this._catchHandler&&(h=h.catch((e=>(t.logger.groupCollapsed(`Error thrown when responding to:  ${o.getFriendlyURL(a)}. Falling back to Catch Handler.`),t.logger.unprefixed.error("Error thrown by:",s),t.logger.unprefixed.error(e),t.logger.groupEnd(),this._catchHandler.handle({url:a,event:r,err:e}))))),h}_findHandlerAndParams(e,t){const r=this._routes.get(e.request.method)||[];for(const o of r){let r=o.match({url:t,event:e});if(r)return(Array.isArray(r)&&0===r.length||r.constructor===Object&&0===Object.keys(r).length||!0===r)&&(r=void 0),{route:o,params:r,handler:o.handler}}return{handler:void 0,params:void 0}}setDefaultHandler(e){this._defaultHandler=n(e)}setCatchHandler(e){this._catchHandler=n(e)}registerRoute(t){e.assert.isType(t,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),e.assert.hasMethod(t,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),e.assert.isType(t.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),e.assert.hasMethod(t.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),e.assert.isType(t.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(t.method)||this._routes.set(t.method,[]),this._routes.get(t.method).push(t)}unregisterRoute(e){if(!this._routes.has(e.method))throw new r.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(!(t>-1))throw new r.WorkboxError("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}class h extends i{constructor(t,{whitelist:r=[/./],blacklist:o=[]}={}){e.assert.isArrayOfClass(r,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.whitelist"}),e.assert.isArrayOfClass(o,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.blacklist"}),super(((...e)=>this._match(...e)),t),this._whitelist=r,this._blacklist=o}_match({event:e,url:r}){if("navigate"!==e.request.mode)return!1;const o=r.pathname+r.search;return this._blacklist.some((e=>e.test(o)))?(t.logger.debug("The navigation route is not being used, since the request URL matches both the whitelist and blacklist."),!1):this._whitelist.some((e=>e.test(o)))?(t.logger.debug("The navigation route is being used."),!0):(t.logger.debug("The navigation route is not being used, since the URL being navigated to doesn't match the whitelist."),!1)}}var c=Object.freeze({RegExpRoute:u,Route:i,Router:l,NavigationRoute:h});e.assert.isSwEnv("workbox-routing");const g=new class extends l{registerRoute(e,o,a="GET"){let s;if("string"==typeof e){const n=new URL(e,location);{if(!e.startsWith("/")&&!e.startsWith("http"))throw new r.WorkboxError("invalid-string",{moduleName:"workbox-routing",className:"DefaultRouter",funcName:"registerRoute",paramName:"capture"});const o="[*:?+]";(e.startsWith("http")?n.pathname:e).match(new RegExp(`${o}`))&&t.logger.debug(`The '$capture' parameter contains an Express-style wildcard character (${o}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}s=new i((({url:r})=>(r.pathname===n.pathname&&r.origin!==n.origin&&t.logger.debug(`${e} only partially matches the cross-origin URL ${r}. This route will only handle cross-origin requests if they match the entire URL.`),r.href===n.href)),o,a)}else if(e instanceof RegExp)s=new u(e,o,a);else if("function"==typeof e)s=new i(e,o,a);else{if(!(e instanceof i))throw new r.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",className:"DefaultRouter",funcName:"registerRoute",paramName:"capture"});s=e}return super.registerRoute(s),s}registerNavigationRoute(r,o={}){e.assert.isType(r,"string",{moduleName:"workbox-routing",className:"[default export]",funcName:"registerNavigationRoute",paramName:"cachedAssetUrl"});const s=a.cacheNames.getPrecacheName(o.cacheName),n=new h((()=>caches.match(r,{cacheName:s}).then((e=>{if(e)return e;throw new Error(`The cache ${s} did not have an entry for ${r}.`)})).catch((e=>(t.logger.debug(`Unable to respond to navigation request with cached response: ${e.message}. Falling back to network.`),fetch(r))))),{whitelist:o.whitelist,blacklist:o.blacklist});return super.registerRoute(n),n}};return self.addEventListener("fetch",(e=>{const t=g.handleRequest(e);t&&e.respondWith(t)})),Object.assign(g,c)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);